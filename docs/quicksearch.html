<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" jsdoc-view Modules jsdoc-view Modules × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" jsdoc-view Modules jsdoc-view jsdoc-view READMEThis extension allows a developer to view the jsdoc documentation for their current project within vscode (in a webview panel). This extension introduces two commands--jsdocView.start, which will open up the jsdoc docs for this project (based on this extension's settings) and jsdocView.generate which will (re)generate said jsdoc documentation (again based on other settings for this extension). If jsdocView.start does not find any documentation in the specified place, it will attempt to generate them (via jsdocView.generate, effectively). This version of this extension also includes an experimental feature to lookup the current word in the editor within the jsdoc documents for the project via docstrap's full text search facilities... Which works as far as it goes. Features Bring up a webview within vscode to display the jsdoc documentation for the current project. Generate the jsdoc documentation for your project from within vscode. RequirementsThis extension assumes the presence of the jsdoc module, although it doesn't call it directly. It does attempt to generate jsdoc documentation indirectly via an npm script (by default it assumes this script is called build-docs, e.g. npm run-script build-docs). Extension SettingsjsdocView.buildScript : Specifies the npm script to run in order to generate the documentation. jsdocView.docDir : The direction into which the documentation will be generated. ! jsdocView.preprocessOptions preprocessOptions.replaceCSP : Will cause the jsdocView processor to replace the &lt;meta Content-Source-Policy...&gt; tag with one it thinks will allow more jsdoc sources to function. preprocessOptions.useCSPolicy : The actual content policy to insert into the generated html pages which get rendered by VSCode. Only used is preprocessOptions.repaceCSP is true. jsdocView.preprocessOptions.fixAttributePaths2 : This is the heart of the preprocessor's work specification, now made entirely configurable. This setting directs the preprocessor which tags to check which attributes for paths which may need fixing. As per heuristic analysis at this time, only schemeless relative paths are altered at this time. This setting is an object, each field of which represents a specific rule. Each rule allows for a short hand of \"tag-name\" as the field index. You can also specify within the rule object itself a tag and selector. All the attributes listed in attrs will be checked and replaced if matching. You can specify for a given rule that you only want tags with specific class decorators to be modified (ifHasClass). You can also specify to explicitly skip tags with a specific class (exceptHasClass). The latter has precedence. If ifHasClass is specified, the default inclusion is false, otherwise it is true. Known Issues Better UI feedback. This is stone age reporting :( Command debouncing (a brief survey shows some debouncing is in place, but I'm 65% sure it's not complete ;) favicon settings do not show up as the icon for the tab in vscode. I have noticed this but not researched it. This extension has not been testing with any template other than docstrap &amp; shinstrap. The tag \"override\" scheme with preprocessOptions.fixAttributePaths2 is not actually necessary for what I originally envisioned it for, but having coded it, I'm leaving it in place for the interim, in case another use for it emerges. In this issue, I am specifically referring to the ability to specify a tag and selector in the body of a rule. GetContext. In the example I have been using, I have only one repos/project, one package.json and one set of jsdocs. But, in roi for instance, I have many. This issue here is that I should be looking for the nearest encapsulating package.json and trying to get docs from it, first (absent the more advanced topic of semantic integration). For the purposes of this issue, this is a \"by file\" question. I.e. based on the currently openned/focused file, which is the closest package.json, and open its docs, if any. This makes settings more complicated because different packages may have different jsdoc settings for location and generation, but our workspace has only one (based on the root level workspace). This implies that I should somehow read these settings out of the package.json of the nearest encapsulating project--doc generation script, doc location. This implies to me that such settings ought to be moved into the respective project's package.json, with this extension holding defaults in its settings. I could try to namespace it by module name though, which probably would work as well and involve less \"corruption\" of client packages. This sounds better. Of course, the logical extension of that pattern is to have a remote db that stores said settings for all known modules &amp; packages, which then would be simpler if they were just stored in each project's package.json and now I've come full circle. The selection of jsdoc source is currently very simplistic (it takes the docs for the current project). This could be augmented to look more carefully at the governing package.json first. Contextually bind textEditor to jsdocView (to scrollTo the relevant entry). The editor context menu algorithm does this in part already, but it uses docstrap's internal \"full-text search\", which sucks, badly. In general, this is a two part problem. I need to identify what semantic element I am on or near within the active text editor. Currently, the closest I've gotten is that I know what word I'm on :/. Get the semantic information is even harder, because vscode does not appear to expose any semantic information on the current document to the extension system. With shinzen and the storage of the jsdoc AST in an sqlite db, this could be much more reasonably acertained. Alternatively, with a service provider server, I could, similar to a language server, parse the file (with a peg parser, for example, for flexbility), and use the [cached] results to inform my identification. I need to determine which file to open for a given reference (which jsdoc file that is). Given the layout of jsdoc files, naming structure, etc. This seems potentially difficult. Specifically, I'd need an informed aliases/identifier table to know what a given label referred to in any given context. This feels like a difficult problem outside an actual runtime, particularly for a loosy-goosey language like Javascript :). Now one thing I do have access to is the source ranges from jsdoc doclets as they are built. So it is possible I could build a mapping file (similar to, but not literally the same as a debugger mapping file), to map ranges in the source code with jsdoc files. This seems plausible. Odds are, to get a \"good\" result I'm going to need a weighted montage of strategies. The anchor scrollTo helper function utilizes scrollIntoView which appears to be slightly off in its calculations, as it doesn't factor in the navbar. This is a polyfill/patch type issue as there are many circumstances that might cause this problem, and an ideal solution would detect them and offset as appropriate. Since I do not have an enumeration of the possible issues, it's hard to do a reasonable patch. I am currently doing an \"arbitrary\" 65px offset. I could calculate the exact cut out for the navbar for docstrap, but as I said, this doesn't feel like it would particularly map to other templates, layouts and styles. Preprocessing html pages for display in vscode's webview has some known issues I need to verify that the path in question is relative. We do not fix-up paths for non-windows platforms. Change configuration options Allow non-npm based script for jsdoc generation ? Do we need jsdoc generation options to vary by active file? Doesn't seem like it. (--yes, of course we do) See also the extensions KB for its extended list of WIP issues. Futures Backwards hook-in -- shim source code links to open the texteditor in the appropriate location. Service implementation -- Alter the structure of this extension to use a service which starts itself up on demand and serves the jsdoc information to the webview. The service would shut itself down after timeout (because it can always be spun back up anyway). This service would then be responsible for doing any preprocessing (probably much less necessary), search, etc. type patterns. source code references \"should\" be patched to open up that source line in the editor Look at building a css sheet for #2 &amp; #3 which takes advantage of css vars and VSCode's use thereof. code { color: var(--vscode-editor-foreground); } Synchronize between the active source file in the text editor and the webview (not even sure that's desireable). Release NotesSee the Changelog for details. × Search results Close "},"module-jsdoc-view.html":{"id":"module-jsdoc-view.html","title":"Module: jsdoc-view","body":" jsdoc-view Modules jsdoc-view Module: jsdoc-view The jsdoc-view is a vscode extension which adds support for viewing jsdoc generated documentation within vscode. algorithm Currently, this extension works by preprocessing and sanitizing each jsdoc generated page live, in memory to allow it to work within the context of a vscode webview panel. Communication between vscode and the jsdoc page is maintained via posted message events (this is standard practice). This extension currently has special handling on both sides for performing a full text search and for openning a file to a particular element. × Search results Close "},"tutorial-DESIGN.html":{"id":"tutorial-DESIGN.html","title":"Tutorial: DESIGN","body":" jsdoc-view Modules jsdoc-view DESIGN #{ ToDo getShimmedContent and loadJSDoc are almost the exact same thing. Should probably remove one and clean up the code. even getJSDocContent is only slightly different from the other two. Double check into retainContextWhenHidden and verify that this isn't something I need to worry about. (I recall looking at this before, but I'm less confident of my memory that it wasn't apropos) Webview API example } Design Debates!{ Total aside Now that I've been using this pattern more, this isn't exactly a DESIGN document as much as it is a dev journal. Perhaps I should rename it. -- Actually what I've done elsewhere is split them into two separate documents } CHANGELOG.md is nice and all for consumers of the extension, but really I want a similar document with notes for me about changes to the internal structure of this extension, its algorithms and the like. I already have some facilities to accomplish this in place via shinstrap and shin-jsdoc-tags. Actually I like this thought, but I need to extend those tags to include commit refs and use shinzen to produce reports thereof. Then I could refrain from maintaining a DEV-CHANGELOG.md, per se, but rather generate one from doc comments made as the changes were put into place, which feels more intelligent, although susceptible, perhaps, to laziness. The Service modelThe question is wether to create a separate detached process to handle processing (similar to how language services are handled) and send messages back and forth to it to handle html preprocessing and to do keyword look ups. Without reading more about Langauge services, the idea here would be to spawn a detached process that would shut itself down after a certain period of inactivity, and would take requests over a named pipe, possibly keyed to either its or its launcher's pid, and would basically do the preprocessing/shimming of pages, and calculations like, which set of docs to view and what to display, anchors, etc. on behalf of the extension and just route the results back to here. [extension]: Open webview with params (e.g. localResourceRoots:), basically specifying which jsdoc cluster to display Take and pass to webview messages (e.g. search or scrollTo) [provider]: Take an open request in a file on a word and figure out which jsdoc cluster to work with, and what lookup to call (this is potentially the wrong way to do this).This is the basis of advanced contextual binding/intellisense NotesAnother webviewPanel bugSo, when a webviewPanel is no longer visible, it gets destroyed. It does not, however, call dispose. It then is silently recreated when it comes into focus again. This means that the panel's contents are reloaded and are temporarily unavailable (vis a vis messages). This is an additional issue to message ready below, because this recurs every time the webview panel is hidden. There is an event, however, that appears to work--onDidChangeViewState. The shim alternativeRather than shim all the links, I've put in an event intercept on the document to look for clicks on links and override them as appropriate. Thus far, this has worked fine. I'm catching, iir, document.onclick to intercept such events. This may have issues I haven't thought of. I annotate here this article I didn't read on event bubbling, in case this turns out to require investigation. message readyI have uncovered an architectural flaw in the webview system where, basically, there is no mechanism that allows an extension to know when a webview is ready. Instead, I will need to roll my own. This is basically going to be a two part problem. First, I need to have the webview notify the extension when it is ready (in document.ready). Second, I need to wrapper _panel.webview.postMessage such that any messages sent to the webview before its ready are instead put onto a queue and get sent, instead, when it receives the webviewReady message. The docstrap searchDocstrap conducts its search in a frame. Why? I have no idea. This frame loads up some sources of the file, does a search in a dataUrl which has the full text in it (ok, so that's why, but...). When it retrieves an answer it posts it back to root frame, despite cross-domain issues (at least I have cross-domain issues trying to talk between these frames, I don't know the rules by which some operations/fields are accessible but others are not in chrome). Less importantly, docstrap creates the iframe in client on document ready. It attaches a listener to the faux-submit button and sends messages (e.g. postMessage) between the button, the iframe and back. The actual results are displayed in a results div on the main page which is populated dynamically. The iframe is never dispayed or interacted with, afaik, it is just a mechanism for deferred loading. Anchors &amp; GotosWe can within an iframe grab an element and scrollIntoView() it. $(\"a[name=\" + _anchor + \"]\")[0].scrollIntoView();I also know, at least for docstrap, that it has a lib which on opening a source file sets a specific anchor pattern for each source line therein. This is probably a jsdoc convention, and not specific to docstrap. This is accomplished by a document.ready based decorator than sweeps the file adding anchors to every source line (as I recall). $('#active-frame').contentWindow.scrollTo(0,300) $('#active-frame').contentWindow.scrollY Works, but only from the context of the debugger, which is working from a global context. In shim-helpers.js, we have a different scope of access. There we need to use window.self. If defined, this is the contentWindow for the current document. window.top is the root window. If undefined there is only one window. I'm not sure if all the browsers use this pattern, but it holds for the webkit used by atom/electron/vscode. Thus... window.self.scrollY window.self.scrollTo(0, 300) Gotchas#{ Release Notes (Log) I have removed shims from preprocessing. All links go through an event capture mechanism now, which intercepts and reroutes anchor links to local path relative urls. This is in alpha and may have bugs. } Paths in createWebViewNormal paths did not work. You have to run them through vscode.Uri.file. let workspacePath = vscode.Uri.file(vscode.workspace.rootPath); let extentionPath = vscode.Uri.file(context.extensionPath); if(jsdocViewState.panel === undefined) { jsdocViewState.panel = vscode.window.createWebviewPanel( 'jsdocView', \"JSDoc View\", columnToShowIn, { enableScripts: true, localResourceRoots: [ workspacePath, extentionPath // vscode.workspace.rootPath // path.join(vscode.workspace.rootPath, \"docs\"), // path.join(vscode.workspace.rootPath, \"node_modules/ink-docstrap/template/static/styles\") ] } );Serializer didn't work...// Neither of these work. context.subscriptions.push(vscode.window.registerWebviewPanelSerializer('jsdocView', (_panel, _state) =&gt; { jsdocViewState.panelReady = false; })); vscode.window.registerWebviewPanelSerializer('jsdocView', (_panel, _state) =&gt; { jsdocViewState.panelReady = false; }); // with the following as activationEvents in `package.json` \"onWebviewPanel:jsdocView\"Old Experimentsfunction shinTest(_panel) { let t = path.join(vscode.workspace.rootPath, \"test.html\"); fs.readFile(t, (err, data) =&gt; { if(err) { vscode.window.showErrorMessage(util.format(\"jsdocView encountered an error: %s\", err.message)); } _panel.webview.html = data.toString(); }); } function loadTest(_panel, _fileName) { let t = path.join(vscode.workspace.rootPath, _fileName); fs.readFile(t, (err, data) =&gt; { if(err) { vscode.window.showErrorMessage(util.format(\"jsdocView encountered an error: %s\", err.message)); } _panel.webview.html = data.toString(); }); }original \"shimHtml()\" codeAlong with the code below, the following settings were removed from this extension's package.json... , \"jsdocView.preprocessOptions.fixAttributePaths\": { \"type\": \"boolean\", \"default\": true, \"description\": \"[deprecated]: Set to true if you want the jsdocView preprocessor to change all attribute paths in script, link &amp; anchor tags without a protocol to use vscode-resource:\" }, \"jsdocView.preprocessOptions.shimLinks\": { \"type\": \"boolean\", \"default\": true, \"description\": \"[deprecated]: Instructs the preprocessor to shin anchor link tags with a function which will allow them to work in Visual Code.\" }, \"jsdocView.preprocessOptions.shimLinkExcludeClasses\": { \"type\": \"array\", \"default\": [ \"dropdown-toggle\" ], \"description\": \"[deprecated]: A list of anchor classes for which no shims should be inserted.\" } The deprecated notes ;) preprocessOptions.shimLinks : If true, the preprocessor will replace the href values on &lt;a&gt; tags with relative paths with an onclick shimmed function which will message vscode itself to update the webview's location. preprocessOptions.shimLinkExcludeClasses : An array of class names any of which if present on a given tag indicate that the tag should not be shimmed, even if it would otherwise qualify. This allows one to specify overrides for tags which may be shimmed by other functions (like the navbar in docstrap). preprocessOptions.fixAttributePaths : Will cause the jsdocView preprocessor to replace the href and src attribute values of &lt;script&gt;, &lt;link&gt; and &lt;a&gt; tags which do not specify a protocol with an absolute pathed value with the vscode-resource: protocol. Relative paths are assumed to be in the docsDir. shimHtml() : /** @desc Process the html provided to make it functional within the gimped environment of a vscode webview. @algorithm This function takes its direction from the configuration settings in jsdocView.preprocessOptions.*. Replace CSP Replace src attributes on &lt;script&gt; and &lt;a&gt; tags shim &lt;a&gt; tags @remarks Passing _sHtml on the stack is probably unwise for large files. I deliberate how else I might want to deal. I could use a global, with the potentialy messes that introduces to avoid copying on the stack. I could roll reading of the file into this function. I could box the string buffer and pass it that way, which is probably what I should do. @param {string} _sHtml The string \"buffer\" containing the html to process. See remarks. @param {} _extPath / function shimHtml(_sHtml, _extPath) { const $ = cheerio.load(_sHtml); const { URL } = require('url'); // Now doing this twice... const config = vscode.workspace.getConfiguration('jsdocView'); let docDir = config.get(\"docDir\"); let projectRootPath = vscode.workspace.rootPath.replace(/\\/g, \"/\"); //! _path = path.normalize(_path); &lt;-- Why didn't this work // win32 patch let drive = projectRootPath.substring(0, projectRootPath.lastIndexOf(\":\")+1); projectRootPath = projectRootPath.substring(projectRootPath.lastIndexOf(\":\")+1); let docPath = path.posix.join(projectRootPath, docDir); //#region Helper functions function hasNoProtocol(_url) { // So I knew it would be wasteful, but it turns out its requirements cause it to be fail prima facia. // let url = new URL(_url, docDir); // So I should look up the RFC for protocol specification. This seems fragile. if(/^[\\w-_]+:/.test(_url)) { return false; } return true; } function normalizePath(_el, _sAttr) { let el = $(_el); let url = el.attr(_sAttr); // The trouble here is, relative to what, potentially. let p = path.posix.join(docPath, url); p = util.format(\"vscode-resource:/%s%s\", drive, p); el.attr(_sAttr, p); } /** @remarks At the moment, all shims are doc dir relative (and treated that way by the shim as well). @param {object} _el */ function insertShim(_el) { let el = $(_el); // super fragile let ap = el.attr('href'); // ap = path.posix.join(docDir, ap); // ap = ap.replace(/\\/g, \"/\"); // let p = path.posix.relative(projectRootPath, ap); el.attr('href', null); el.attr(\"onclick\", util.format(\"ss_shim_nav('%s')\", ap)); } //#endregion try { // add/replace content-src policy if(config.get(\"preprocessOptions.replaceCSP\")) { //&lt;meta http-equiv=\"Content-Security-Policy\" let csp = $('meta[http-equiv=Content-Security-Policy]'); if(csp.length &gt;0) { csp.attr('content', \"default-src vscode-resource: https: http: data:; img-src vscode-resource: https: data: http:; script-src 'unsafe-inline' 'unsafe-eval' vscode-resource: http:; style-src 'unsafe-inline' vscode-resource: https: http:;\"); } else { $('head').prepend('&lt;meta http-equiv=\"Content-Security-Policy\" content=\"default-src vscode-resource: https: http: data:; img-src vscode-resource: https: http: data:; script-src \\'unsafe-inline\\' \\'unsafe-eval\\' vscode-resource: http:; style-src \\'unsafe-inline\\' vscode-resource: https: http:;\"&gt;'); } } // $('body').append(''); // fix link and script tags if(config.get(\"preprocessOptions.fixAttributePaths\")) { $('[href]').each((idx, el) =&gt; { let e = $(el); }); $('script').filter(function() { return this.attribs.src !== undefined; }).each((idx, el) =&gt; { if(hasNoProtocol(el.attribs.src)) { normalizePath(el, \"src\"); } }); $('link[rel=stylesheet]').filter(function() { return this.attribs.href !== undefined; }).each((idx, el) =&gt; { if(hasNoProtocol(el.attribs.href)) { normalizePath(el, \"href\"); } }); } let exclusion = config.get(\"preprocessOptions.shimLinkExcludeClasses\"); if(config.get(\"preprocessOptions.shimLinks\")) { // insert shim helpers $('head').append(util.format('&lt;script src=\"vscode-resource:/%s\"&gt;&lt;/script&gt;', path.join(_extPath, '/lib/jsdocViewIntegration.js').replace(/\\\\/g, \"/\"))); // and a link style //! should I retrieve the cursor style for a default anchor? $('head').append(`&lt;style&gt;a[onclick] { cursor: pointer }&lt;/style&gt;`); } else { // I should split them up, but I use shim helpers for more than just shims now $('head').append(util.format('&lt;script src=\"vscode-resource:/%s\"&gt;&lt;/script&gt;', path.join(_extPath, '/lib/jsdocViewIntegration.js').replace(/\\\\/g, \"/\"))); } $('a').filter(function() { return this.attribs.href !== undefined; }).each((idx, el) =&gt; { let shimmed = false; if(config.get(\"preprocessOptions.shimLinks\")) { // if this anchor isn't excluded if(!exclusion.reduce(function(acc, excl) { if($(el).hasClass(excl)) { return true; } else { return acc; } }, false)) { // replace all normal links with onclick references if(hasNoProtocol(el.attribs.href)) { insertShim(el); shimmed = true; } } } // temp testing if(exclusion.reduce(function(acc, excl) { if($(el).hasClass(excl)) { return true; } else { return acc; } }, false)) { if(!shimmed &amp;&amp; config.get(\"preprocessOptions.fixAttributePaths\")) { if(hasNoProtocol(el.attribs.href)) { normalizePath(el, \"href\"); } } } }); } catch(e) { console.log(\"Something happened %s\", e); } // $('a').filter(function() { // // This is specifically filtering to avoid navbar expansions/replacements in the menu of docstrap jsdoc. // return this.attribs.href !== undefined &amp;&amp; this.attribs.class.indexOf(\"navbar-brand\") === -1; // }).each((idx, el) =&gt; { // let e = $(el); // let ap = e.attr('href'); // ap = ap.substring(ap.lastIndexOf(\":\")+1); // let p = path.posix.relative(rp, ap); // e.attr('href', null); // e.attr(\"onclick\", util.format(\"ss_shim_nav('%s')\", p)); // }); // Scroll //$(document).ready(function() { //document.getElementById(\"anchorTest\").scrollIntoView(); }); return $.html(); } × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
